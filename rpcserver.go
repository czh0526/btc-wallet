package main

import (
	"crypto/tls"
	"errors"
	"fmt"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/czh0526/btc-wallet/rpc/rpcserver"
	"github.com/czh0526/btc-wallet/wallet"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"net"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

func startWalletRPCServices(wallet *wallet.Wallet, server *grpc.Server) {
	if server != nil {
		rpcserver.StartWalletService(server, wallet)
	}
}

func startRPCServers(walletLoader *wallet.Loader) (*grpc.Server, error) {
	var (
		server  *grpc.Server
		keyPair tls.Certificate
		//legacyListen = net.Listen
		err error
	)

	if cfg.DisableServerTLS {
		return nil, errors.New("Server TLS disabled. Only legacy RPC may be used")
	} else {
		keyPair, err = openRPCKeyPair()
		if err != nil {
			return nil, err
		}

		//tlsConfig := &tls.Config{
		//	Certificates: []tls.Certificate{keyPair},
		//	MinVersion:   tls.VersionTLS12,
		//	NextProtos:   []string{"h2"},
		//}
		//legacyListen = func(net string, laddr string) (net.Listener, error) {
		//	return tls.Listen(net, laddr, tlsConfig)
		//}

		if len(cfg.ExperimentalRPCListeners) != 0 {
			listeners := makeListeners(cfg.ExperimentalRPCListeners, net.Listen)
			if len(listeners) == 0 {
				return nil, errors.New("failed to create listeners for RPC server")
			}
			creds := credentials.NewServerTLSFromCert(&keyPair)
			// 创建基于 TLS 的 grpc server
			server = grpc.NewServer(grpc.Creds(creds))
			// 将 WalletLoader 注册进 grpc server
			rpcserver.StartWalletLoaderService(server, walletLoader, activeNet)
			// 打开守护端口
			for _, lis := range listeners {
				lis := lis
				go func() {
					fmt.Printf("Experimental RPC server listening on %s", lis.Addr())
					err := server.Serve(lis)
					fmt.Printf("Finished serving expirmental RPC: %v", err)
				}()
			}
		}
	}

	return server, nil
}

func openRPCKeyPair() (tls.Certificate, error) {
	_, err := os.Stat(cfg.RPCKey)
	keyExists := !os.IsNotExist(err)
	switch {
	case cfg.OneTimeTLSKey && keyExists:
		err = fmt.Errorf("one time TLS keys are enabled, but TLS key `%s` already exists", cfg.RPCKey)
		return tls.Certificate{}, err
	case cfg.OneTimeTLSKey:
		return generateRPCKeyPair(false)
	case !keyExists:
		return generateRPCKeyPair(true)
	default:
		return tls.LoadX509KeyPair(cfg.RPCCert, cfg.RPCKey)
	}
}

func generateRPCKeyPair(writeKey bool) (tls.Certificate, error) {
	fmt.Printf("Generating TLS certificates...")

	certDir, _ := filepath.Split(cfg.RPCCert)
	keyDir, _ := filepath.Split(cfg.RPCKey)
	err := os.MkdirAll(certDir, 0700)
	if err != nil {
		return tls.Certificate{}, err
	}
	err = os.MkdirAll(keyDir, 0700)
	if err != nil {
		return tls.Certificate{}, err
	}

	// Generate cert pair
	org := "btc-wallet autogenerated cert"
	validUntil := time.Now().Add(time.Hour * 24 * 365 * 10)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return tls.Certificate{}, err
	}
	keyPair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		return tls.Certificate{}, err
	}

	err = os.WriteFile(cfg.RPCCert, cert, 0600)
	if err != nil {
		return tls.Certificate{}, err
	}
	if writeKey {
		err = os.WriteFile(cfg.RPCKey, key, 0600)
		if err != nil {
			rmErr := os.Remove(cfg.RPCKey)
			if rmErr != nil {
				fmt.Printf("Cannot remove written certificates: %v", rmErr)
			}
			return tls.Certificate{}, err
		}
	}

	fmt.Printf("Done generating TLS certificates")
	return keyPair, nil
}

type listenFunc func(net string, laddr string) (net.Listener, error)

func makeListeners(normalizedListenAddrs []string, listen listenFunc) []net.Listener {
	ipv4Addrs := make([]string, 0, len(normalizedListenAddrs)*2)
	ipv6Addrs := make([]string, 0, len(normalizedListenAddrs)*2)
	for _, addr := range normalizedListenAddrs {
		host, _, err := net.SplitHostPort(addr)
		if err != nil {
			fmt.Printf("`%s` is not a normalized listener address", addr)
			continue
		}

		if host == "" || (host == "*" && runtime.GOOS == "plan9") {
			ipv4Addrs = append(ipv4Addrs, addr)
			ipv6Addrs = append(ipv6Addrs, addr)
			continue
		}

		zoneIndex := strings.Index(host, "%")
		if zoneIndex != -1 {
			host = host[:zoneIndex]
		}

		ip := net.ParseIP(host)
		switch {
		case ip == nil:
			fmt.Printf("`%s` is not a valid IP address", host)
		case ip.To4() == nil:
			ipv6Addrs = append(ipv6Addrs, addr)
		default:
			ipv4Addrs = append(ipv4Addrs, addr)
		}
	}

	listeners := make([]net.Listener, 0, len(ipv6Addrs)+len(ipv4Addrs))
	for _, addr := range ipv4Addrs {
		listener, err := listen("tcp4", addr)
		if err != nil {
			fmt.Printf("Can't listen on %s: %v", addr, err)
			continue
		}
		listeners = append(listeners, listener)
	}
	for _, addr := range ipv6Addrs {
		listener, err := listen("tcp6", addr)
		if err != nil {
			fmt.Printf("Can't listen on %s: %v", addr, err)
			continue
		}
		listeners = append(listeners, listener)
	}

	return listeners
}
